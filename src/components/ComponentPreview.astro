---
interface Props {
  src: string
  title: string
  dark?: boolean
  index?: number
  wrapper?: string
}

const { src, title, dark = false, index = 1, wrapper = '' } = Astro.props
---

<component-preview data-src={src} class="block">
  <iframe
    data-preview="true"
    src={src}
    title={title}
    class:list={[
      wrapper,
      dark ? 'bg-gray-900' : 'bg-white',
      'w-full rounded-xl shadow-sm ring ring-stone-300 transition-[max-width] duration-300 data-[preview=false]:hidden data-[preview=true]:block',
    ]}
    style="max-width: 100%;"
    loading={index === 1 && !dark ? 'eager' : 'lazy'}></iframe>

  <div
    data-preview="true"
    class="prose prose-pre:m-0 prose-pre:rounded-xl prose-pre:shadow-sm max-w-none data-[preview=true]:hidden"
  >
    <pre data-html></pre>
  </div>
</component-preview>

<script>
  class ComponentPreview extends HTMLElement {
    private isLoaded = false
    private contentSrc: string | null = null

    private iframeEl: HTMLIFrameElement | null = null
    private previewEl: HTMLDivElement | null = null

    private boundHandlers = new Map<string, EventListener>()

    connectedCallback() {
      this.contentSrc = this.dataset.src || null

      if (!this.contentSrc) {
        return
      }

      this.iframeEl = this.querySelector('iframe') as HTMLIFrameElement | null
      this.previewEl = this.querySelector('[data-html]') as HTMLDivElement | null

      if (!this.iframeEl || !this.previewEl) {
        return
      }

      this.setupEventListeners()
      this.handleInitialLoad()
    }

    disconnectedCallback() {
      this.boundHandlers.forEach((handler, event) => document.removeEventListener(event, handler))

      this.boundHandlers.clear()
    }

    private setupEventListeners() {
      const breakpointHandler = (breakpointEvent: Event) => {
        const breakpointEventTyped = breakpointEvent as CustomEvent
        const newWidth = breakpointEventTyped.detail.width

        if (this.iframeEl) {
          this.iframeEl.style.maxWidth = newWidth
        }
      }

      const viewHandler = (viewEvent: Event) => {
        const viewEventTyped = viewEvent as CustomEvent
        const isPreviewing = viewEventTyped.detail.previewing

        const previewEls: Element[] = [...this.querySelectorAll('[data-preview]')]

        previewEls.forEach((previewEl) => {
          previewEl.setAttribute('data-preview', isPreviewing ? 'true' : 'false')
        })
      }

      const directionHandler = (directionEvent: Event) => {
        const directionEventTyped = directionEvent as CustomEvent
        const isLtr = directionEventTyped.detail.ltr

        const iframeContent = this.getIframeContent()

        if (iframeContent) {
          iframeContent.documentElement.setAttribute('dir', isLtr ? 'ltr' : 'rtl')
        }
      }

      const copyHandler = () => {
        const iframeContent = this.getIframeContent()

        if (iframeContent) {
          const contentHtml = this.sanitizeContent(iframeContent.body.innerHTML)

          navigator.clipboard.writeText(contentHtml)
        }
      }

      const loadHandler = () => this.onIframeLoaded()

      this.boundHandlers.set(`breakpoint:change:${this.contentSrc}`, breakpointHandler)
      this.boundHandlers.set(`preview:view:${this.contentSrc}`, viewHandler)
      this.boundHandlers.set(`preview:direction:${this.contentSrc}`, directionHandler)
      this.boundHandlers.set(`preview:copy:${this.contentSrc}`, copyHandler)
      this.boundHandlers.set(`iframe:load`, loadHandler)

      this.iframeEl?.addEventListener('load', loadHandler)

      document.addEventListener(`breakpoint:change:${this.contentSrc}`, breakpointHandler)
      document.addEventListener(`preview:view:${this.contentSrc}`, viewHandler)
      document.addEventListener(`preview:direction:${this.contentSrc}`, directionHandler)
      document.addEventListener(`preview:copy:${this.contentSrc}`, copyHandler)
    }

    private handleInitialLoad() {
      if (!this.iframeEl) {
        return
      }

      try {
        if (this.iframeEl.contentDocument?.readyState === 'complete') {
          this.onIframeLoaded()
        }
      } catch {
        // We do nothing
      }
    }

    private async onIframeLoaded() {
      if (this.isLoaded) {
        return
      }

      const iframeContent = this.getIframeContent()

      if (!iframeContent) {
        return
      }

      const sanitizedContent = this.sanitizeContent(iframeContent.body.innerHTML)

      if (!this.previewEl) {
        return
      }

      this.previewEl.textContent = sanitizedContent

      this.isLoaded = true
    }

    private getIframeContent(): Document | null {
      try {
        return this.iframeEl?.contentDocument || this.iframeEl?.contentWindow?.document || null
      } catch {
        return null
      }
    }

    private sanitizeContent(contentHtml: string): string {
      const INDENTATION_SPACES = 4

      return contentHtml
        .split('\n')
        .map((htmlLine) => htmlLine.replace(new RegExp(`^\\s{${INDENTATION_SPACES}}`, ''), ''))
        .join('\n')
        .trim()
    }
  }

  customElements.define('component-preview', ComponentPreview)
</script>
